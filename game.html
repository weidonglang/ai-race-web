<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>方块世界 - 沙盒演示</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
        }

        /* 顶部右侧品牌 Logo */
        .logo-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            text-decoration: none;
            font-weight: 600;
            z-index: 12;
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
        }

        .logo-badge img {
            width: 28px;
            height: 28px;
            display: block;
        }

        /* 准星 */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #crosshair::before,
        #crosshair::after {
            content: "";
            position: absolute;
            background: white;
        }

        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        /* 信息框 */
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 8px;
            z-index: 10;
            max-width: 300px;
        }

        #info h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        #info p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        /* 底部物品栏 */
        #inventory-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 5px;
            z-index: 10;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #888;
            margin: 0 3px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-transform: capitalize;
            box-sizing: border-box;
            user-select: none;
            transition: all 0.1s ease-out;
        }

        .inventory-slot.selected {
            border-color: #ffffff;
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <a class="logo-badge" href="index.html" title="返回首页">
        <img src="/log.svg" alt="AI Race logo">
        <span>AI Race</span>
    </a>
    <div id="crosshair"></div>
    <div id="info">
        <h2>方块世界</h2>
        <p><b>移动：</b> W / A / S / D</p>
        <p><b>跳跃：</b> 空格</p>
        <p><b>视角：</b> 鼠标移动</p>
        <p><b>破坏方块：</b> 鼠标左键</p>
        <p><b>放置方块：</b> 鼠标右键</p>
        <p><b>切换方块：</b> 鼠标滚轮</p>
        <p><b>提示：</b> 点击页面锁定鼠标</p>
    </div>
    <div id="inventory-bar"></div>

    <!-- three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // ================== 基本变量 ==================
        let scene, camera, renderer, clock;
        let blocks, outlineMesh;
        let raycaster, selectedBlock;
        let isGrounded = false;

        const keys = {};

        // 世界 / 玩家参数（世界略缩小一点，性能好一些）
        const worldSize = { width: 32, depth: 32, height: 8 };
        const blockSize = 1;
        const playerHeight = 1.8;
        const playerWidth = 0.4;
        const playerBoxSize = new THREE.Vector3(
            playerWidth,
            playerHeight,
            playerWidth
        );
        const gravity = 30; // m/s^2
        const moveSpeed = 5; // m/s
        const jumpStrength = 10; // m/s
        const reachDistance = 5; // blocks
        const RENDER_DISTANCE = 70; // 雾的最远距离（类似渲染距离）

        // 运动相关
        let velocity = new THREE.Vector3();
        let moveVector = new THREE.Vector3();

        // 方块类型
        const blockTypes = ["grass", "dirt", "stone", "wood", "leaf"];
        let currentBlockIndex = 0;

        // ======== 纹理加载（Minecraft 风格） =========
        const textureLoader = new THREE.TextureLoader();

        function loadBlockTexture(path) {
            const tex = textureLoader.load(path);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.anisotropy = 1;
            return tex;
        }

        const texGrassTop = loadBlockTexture("textures/grass_top.png");
        const texGrassSide = loadBlockTexture("textures/grass_side.png");
        const texDirt = loadBlockTexture("textures/dirt.png");
        const texStone = loadBlockTexture("textures/stone.png");
        const texLogSide = loadBlockTexture("textures/log_side.png");
        const texLogTop = loadBlockTexture("textures/log_top.png");
        const texLeaves = loadBlockTexture("textures/leaves.png");

        // BoxGeometry 6 个面的顺序：
        // [right, left, top, bottom, front, back]
        const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: texGrassSide }),
                new THREE.MeshLambertMaterial({ map: texGrassSide }),
                new THREE.MeshLambertMaterial({ map: texGrassTop }),
                new THREE.MeshLambertMaterial({ map: texDirt }),
                new THREE.MeshLambertMaterial({ map: texGrassSide }),
                new THREE.MeshLambertMaterial({ map: texGrassSide })
            ],
            dirt: new THREE.MeshLambertMaterial({ map: texDirt }),
            stone: new THREE.MeshLambertMaterial({ map: texStone }),
            wood: [
                new THREE.MeshLambertMaterial({ map: texLogSide }),
                new THREE.MeshLambertMaterial({ map: texLogSide }),
                new THREE.MeshLambertMaterial({ map: texLogTop }),
                new THREE.MeshLambertMaterial({ map: texLogTop }),
                new THREE.MeshLambertMaterial({ map: texLogSide }),
                new THREE.MeshLambertMaterial({ map: texLogSide })
            ],
            leaf: new THREE.MeshLambertMaterial({
                map: texLeaves,
                transparent: true,
                opacity: 0.9
            })
        };

        // 用 Map 存世界里的方块，方便查重
        const worldMap = new Map();
        function blockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        // ================== 简单噪声函数，生成地形 ==================
        function rand2D(x, z) {
            const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453;
            return s - Math.floor(s);
        }

        // 更平滑的高度：低频大山 + 高频细节
        function getHeightAt(x, z) {
            const scaleLarge = 0.03;  // 大范围平缓起伏
            const scaleSmall = 0.1;   // 小范围细节

            const h1 = rand2D(x * scaleLarge, z * scaleLarge);
            const h2 = rand2D(x * scaleSmall, z * scaleSmall);

            // 大形占 0.8，细节占 0.2
            let e = 0.8 * h1 + 0.2 * h2;

            // 控制绝对高度区间
            const minHeight = 6;
            const maxHeight = 14;
            return Math.round(minHeight + e * (maxHeight - minHeight));
        }

        // ================== 出生点计算（修好卡脚） ==================
        function getSpawnPosition() {
            const x = Math.floor(worldSize.width / 2);
            const z = Math.floor(worldSize.depth / 2);

            const blockCenterY = getHeightAt(x, z);  // 方块中心 y
            const groundTopY = blockCenterY + 0.5;   // 方块顶部 = 真正地面

            // 玩家脚底在地面上方一点点
            let spawnPos = new THREE.Vector3(
                x,
                groundTopY + playerHeight + 0.05,
                z
            );

            // 如果不小心和树 / 其他方块重叠，往上挪几次直到不碰撞
            for (let i = 0; i < 10; i++) {
                const collider = getPlayerCollider(spawnPos);
                if (!checkCollision(collider)) break;
                spawnPos.y += 0.5;
            }

            return spawnPos;
        }

        function resetPlayerPosition() {
            const spawnPos = getSpawnPosition();
            camera.position.copy(spawnPos);
            velocity.set(0, 0, 0);
            isGrounded = false;
        }

        // ================== 初始化 ==================
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(
                0x87ceeb,
                RENDER_DISTANCE * 0.2,
                RENDER_DISTANCE
            );

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.rotation.order = "YXZ";

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 性能优化：限制像素比 + 关闭阴影
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = false;

            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // 光照（不用阴影，省性能）
            const ambientLight = new THREE.AmbientLight(0x888888);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = false;
            scene.add(directionalLight);

            // 方块组
            blocks = new THREE.Group();
            scene.add(blocks);

            // 生成世界
            generateWorld();

            // 把玩家放到一个安全的出生点（地面上方）
            resetPlayerPosition();

            // Raycaster
            raycaster = new THREE.Raycaster();

            // 高亮方块轮廓
            const outlineGeometry = new THREE.EdgesGeometry(
                new THREE.BoxGeometry(1.01, 1.01, 1.01)
            );
            const outlineMaterial = new THREE.LineBasicMaterial({
                color: 0x000000
            });
            outlineMesh = new THREE.LineSegments(
                outlineGeometry,
                outlineMaterial
            );
            outlineMesh.visible = false;
            scene.add(outlineMesh);

            // UI 事件
            setupEventListeners();

            // 创建物品栏
            createInventoryBar();

            animate();
        }

        // ================== 世界生成 ==================
        function generateWorld() {
            const geometry = new THREE.BoxGeometry(
                blockSize,
                blockSize,
                blockSize
            );

            for (let x = 0; x < worldSize.width; x++) {
                for (let z = 0; z < worldSize.depth; z++) {
                    const yTop = getHeightAt(x, z);

                    // 顶层草
                    addBlockWithGeometry(x, yTop, z, "grass", geometry);

                    // 下面几层泥土
                    for (let dy = yTop - 1; dy > yTop - 4 && dy > 0; dy--) {
                        addBlockWithGeometry(x, dy, z, "dirt", geometry);
                    }
                    // 再下面是石头
                    for (let dy = yTop - 4; dy > 0; dy--) {
                        addBlockWithGeometry(x, dy, z, "stone", geometry);
                    }
                    // 基岩
                    addBlockWithGeometry(x, 0, z, "stone", geometry);

                    // 随机生成树（高度较高的地方才长树）
                    if (Math.random() < 0.02 && yTop > worldSize.height) {
                        generateTree(x, yTop + 1, z);
                    }
                }
            }
        }

        function generateTree(x, y, z) {
            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4-6
            // 树干
            for (let i = 0; i < trunkHeight; i++) {
                addBlock(x, y + i, z, "wood");
            }
            const topY = y + trunkHeight;

            // 叶子层
            for (let lx = -2; lx <= 2; lx++) {
                for (let ly = -1; ly <= 1; ly++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        if (lx === 0 && lz === 0 && ly < 1) continue;
                        if (Math.abs(lx) + Math.abs(lz) > 4) continue;
                        addBlock(x + lx, topY + ly, z + lz, "leaf");
                    }
                }
            }
            // 顶部几片叶子
            addBlock(x, topY + 2, z, "leaf");
            addBlock(x + 1, topY + 2, z, "leaf");
            addBlock(x - 1, topY + 2, z, "leaf");
            addBlock(x, topY + 2, z + 1, "leaf");
            addBlock(x, topY + 2, z - 1, "leaf");
        }

        // 复用几何体版本
        function addBlockWithGeometry(x, y, z, type, geometry) {
            const key = blockKey(x, y, z);
            if (worldMap.has(key)) return;

            const mat = materials[type] || materials["stone"];
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.set(x, y, z);
            // 性能优化：关闭单方块阴影
            mesh.receiveShadow = false;
            mesh.castShadow = false;
            mesh.userData.type = type;
            blocks.add(mesh);
            worldMap.set(key, mesh);
        }

        function addBlock(x, y, z, type) {
            const key = blockKey(x, y, z);
            if (worldMap.has(key)) return;

            const mat = materials[type] || materials["stone"];
            const geometry = new THREE.BoxGeometry(
                blockSize,
                blockSize,
                blockSize
            );
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = false;
            mesh.castShadow = false;
            mesh.userData.type = type;
            blocks.add(mesh);
            worldMap.set(key, mesh);
        }

        // ================== 事件 & 物品栏 ==================
        function createInventoryBar() {
            const inventoryBar = document.getElementById("inventory-bar");
            for (let i = 0; i < blockTypes.length; i++) {
                const slot = document.createElement("div");
                slot.classList.add("inventory-slot");
                slot.dataset.index = i;
                slot.textContent = blockTypes[i];
                inventoryBar.appendChild(slot);
            }
            updateInventoryUI();
        }

        function updateInventoryUI() {
            const slots = document.querySelectorAll(".inventory-slot");
            slots.forEach((slot) => {
                if (parseInt(slot.dataset.index) === currentBlockIndex) {
                    slot.classList.add("selected");
                } else {
                    slot.classList.remove("selected");
                }
            });
        }

        function setupEventListeners() {
            document.addEventListener("keydown", (e) => {
                if (e.key === 'Escape') {
                    window.location.href = 'help.html'
                    return
                }
                keys[e.code] = true;
            });
            document.addEventListener("keyup", (e) => {
                keys[e.code] = false;
            });

            // 点击进入指针锁定
            document.addEventListener("click", () => {
                document.body.requestPointerLock();
            });

            // 鼠标控制视角
            document.addEventListener("mousemove", (e) => {
                if (document.pointerLockElement === document.body) {
                    const sensitivity = 0.002;
                    camera.rotation.y -= e.movementX * sensitivity;
                    camera.rotation.x -= e.movementY * sensitivity;
                    const halfPi = Math.PI / 2;
                    camera.rotation.x = Math.max(
                        -halfPi,
                        Math.min(halfPi, camera.rotation.x)
                    );
                }
            });

            // 鼠标点击破坏/放置
            document.addEventListener("mousedown", (e) => {
                if (
                    document.pointerLockElement !== document.body ||
                    !selectedBlock
                )
                    return;

                if (e.button === 0) {
                    // 左键破坏
                    const obj = selectedBlock.object;
                    const pos = obj.position;
                    const key = blockKey(pos.x, pos.y, pos.z);
                    blocks.remove(obj);
                    worldMap.delete(key);
                    selectedBlock = null;
                    outlineMesh.visible = false;
                } else if (e.button === 2) {
                    // 右键放置
                    const normal = selectedBlock.face.normal;
                    const newPos =
                        selectedBlock.object.position.clone().add(normal);
                    const playerCollider = getPlayerCollider(camera.position);
                    const newBlockCollider = new THREE.Box3()
                        .setFromCenterAndSize(
                            newPos,
                            new THREE.Vector3(
                                blockSize,
                                blockSize,
                                blockSize
                            )
                        );
                    if (!playerCollider.intersectsBox(newBlockCollider)) {
                        addBlock(
                            newPos.x,
                            newPos.y,
                            newPos.z,
                            blockTypes[currentBlockIndex]
                        );
                    }
                }
            });

            // 滚轮切换方块
            document.addEventListener("wheel", (e) => {
                if (e.deltaY > 0) {
                    currentBlockIndex =
                        (currentBlockIndex + 1) % blockTypes.length;
                } else {
                    currentBlockIndex =
                        (currentBlockIndex - 1 + blockTypes.length) %
                        blockTypes.length;
                }
                updateInventoryUI();
            });

            // 窗口大小变化
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 禁用默认右键菜单
            window.addEventListener("contextmenu", (e) =>
                e.preventDefault()
            );
        }

        // ================== 碰撞 & 物理 ==================
        function getPlayerCollider(position) {
            const center = position
                .clone()
                .sub(new THREE.Vector3(0, playerHeight / 2, 0));
            return new THREE.Box3().setFromCenterAndSize(
                center,
                playerBoxSize
            );
        }

        function checkCollision(playerCollider) {
            // 确定玩家碰撞盒覆盖的整数坐标范围
            const minX = Math.floor(playerCollider.min.x);
            const maxX = Math.ceil(playerCollider.max.x);
            const minY = Math.floor(playerCollider.min.y);
            const maxY = Math.ceil(playerCollider.max.y);
            const minZ = Math.floor(playerCollider.min.z);
            const maxZ = Math.ceil(playerCollider.max.z);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = blockKey(x, y, z);
                        const block = worldMap.get(key);

                        if (block) {
                            const blockCollider = new THREE.Box3().setFromObject(
                                block
                            );
                            if (
                                playerCollider.intersectsBox(blockCollider)
                            ) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateControls(delta) {
            const yaw = camera.rotation.y;
            const forward = new THREE.Vector3(
                -Math.sin(yaw),
                0,
                -Math.cos(yaw)
            );
            const right = new THREE.Vector3(
                Math.cos(yaw),
                0,
                -Math.sin(yaw)
            );

            moveVector.set(0, 0, 0);

            if (keys["KeyW"]) moveVector.add(forward);
            if (keys["KeyS"]) moveVector.sub(forward);
            if (keys["KeyA"]) moveVector.sub(right);
            if (keys["KeyD"]) moveVector.add(right);

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(moveSpeed);
            }

            velocity.x = moveVector.x;
            velocity.z = moveVector.z;

            // 跳跃
            if (keys["Space"] && isGrounded) {
                velocity.y = jumpStrength;
                isGrounded = false;
            }
        }

        function updatePhysics(delta) {
            // 重力
            velocity.y -= gravity * delta;

            const oldPos = camera.position.clone();
            const newPos = oldPos.clone();

            // 垂直轴
            newPos.y += velocity.y * delta;
            let playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                if (velocity.y < 0) {
                    isGrounded = true;
                }
                velocity.y = 0;
                newPos.y = oldPos.y;
            } else {
                isGrounded = false;
            }

            // X 轴
            newPos.x += velocity.x * delta;
            playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                newPos.x = oldPos.x;
            }

            // Z 轴
            newPos.z += velocity.z * delta;
            playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                newPos.z = oldPos.z;
            }

            camera.position.copy(newPos);

            // 掉出世界就传送回安全出生点
            if (camera.position.y < -20) {
                resetPlayerPosition();
            }
        }

        // ================== 交互（选中方块） ==================
        function updateInteraction() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObjects(
                blocks.children,
                false
            );

            if (intersects.length > 0 && intersects[0].distance < reachDistance) {
                selectedBlock = intersects[0];
                outlineMesh.position.copy(selectedBlock.object.position);
                outlineMesh.visible = true;
            } else {
                selectedBlock = null;
                outlineMesh.visible = false;
            }
        }

        // ================== 动画循环 ==================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // 不再检查 pointerLockElement，始终更新控制和物理
            updateControls(delta);
            updatePhysics(delta);

            updateInteraction();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

