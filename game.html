<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>方块世界 - 沙盒演示</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        canvas {
            display: block;
        }

        /* 顶部右侧品牌 Logo */
        .logo-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            text-decoration: none;
            font-weight: 600;
            z-index: 12;
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
        }

        .logo-badge img {
            width: 28px;
            height: 28px;
            display: block;
        }

        /* 准星 */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        #crosshair::before,
        #crosshair::after {
            content: "";
            position: absolute;
            background: white;
        }

        #crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        /* 信息框 */
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border-radius: 8px;
            z-index: 10;
            max-width: 300px;
        }

        #info h2 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }

        #info p {
            margin: 5px 0;
            font-size: 0.9em;
        }

        /* 底部物品栏 */
        #inventory-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 5px;
            z-index: 10;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #888;
            margin: 0 3px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-transform: capitalize;
            box-sizing: border-box;
            user-select: none;
            transition: all 0.1s ease-out;
        }

        .inventory-slot.selected {
            border-color: #ffffff;
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <a class="logo-badge" href="index.html" title="返回首页">
        <img src="/log.svg" alt="AI Race logo">
        <span>AI Race</span>
    </a>
    <div id="crosshair"></div>
    <div id="info">
        <h2>方块世界</h2>
        <p><b>移动：</b> W / A / S / D</p>
        <p><b>跳跃：</b> 空格</p>
        <p><b>视角：</b> 鼠标移动</p>
        <p><b>破坏方块：</b> 鼠标左键</p>
        <p><b>放置方块：</b> 鼠标右键</p>
        <p><b>切换方块：</b> 鼠标滚轮</p>
        <p><b>提示：</b> 点击页面锁定鼠标</p>
    </div>
    <div id="inventory-bar"></div>

    <script type="module">
        import * as THREE from "three";
        import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
        import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
        import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
        import { FXAAShader } from "three/examples/jsm/shaders/FXAAShader.js";
        // ================== 基本变量 ==================
        let scene, camera, renderer, clock, composer, fxaaPass;
        let blocks, outlineMesh;
        let raycaster, selectedBlock;
        let directionalLight, hemiLight;
        let qualityLabelEl;
        let isGrounded = false;

        const ENABLE_FXAA = false; // 需要更锐利画面时关闭 FXAA（抗锯齿轻微模糊）
        const ENABLE_SSAO = false; // 保持关闭，避免多实例冲突
        let maxAnisotropy = 1;
        const loadedTextures = [];

        const keys = {};

        // 世界 / 玩家参数（世界略缩小一点，性能好一些）
        const worldSize = { width: 64, depth: 64, height: 16 };
        const blockSize = 1;
        const playerHeight = 1.8;
        const playerWidth = 0.4;
        const playerBoxSize = new THREE.Vector3(
            playerWidth,
            playerHeight,
            playerWidth
        );
        const gravity = 30; // m/s^2
        const moveSpeed = 5; // m/s
        const jumpStrength = 10; // m/s
        const reachDistance = 5; // blocks
        const RENDER_DISTANCE = 70; // 雾的最远距离（类似渲染距离）

        // 运动相关
        let velocity = new THREE.Vector3();
        let moveVector = new THREE.Vector3();

        // 方块类型
        const blockTypes = ["grass", "dirt", "stone", "wood", "leaf"];
        let currentBlockIndex = 0;
        const sharedBoxGeometry = new THREE.BoxGeometry(
            blockSize,
            blockSize,
            blockSize
        );

        const instancedGroups = new Map(); // type -> { mesh, capacity, count, positions, keys }
        const DEFAULT_INSTANCED_CAPACITY = 80000;
        const dummyObject = new THREE.Object3D();

        // 画质预设（性能可切换）
        const qualityPresets = {
            high: {
                pixelRatio: Math.min(window.devicePixelRatio, 1.5),
                shadows: true,
                shadowMapSize: 1280,
                shadowBias: -0.0005,
                normalBias: 0.02,
                shadowRadius: 0.8,
                exposure: 1.05
            },
            balanced: {
                pixelRatio: Math.min(window.devicePixelRatio, 1.25),
                shadows: true,
                shadowMapSize: 896,
                shadowBias: -0.0006,
                normalBias: 0.02,
                shadowRadius: 0.6,
                exposure: 0.9
            },
            performance: {
                pixelRatio: 1.0,
                shadows: false,
                shadowMapSize: 512,
                shadowBias: -0.0003,
                normalBias: 0.01,
                shadowRadius: 0,
                exposure: 0.85
            }
        };
        let qualityMode = "balanced";

        // ======== 纹理加载（Minecraft 风格） =========
        const textureLoader = new THREE.TextureLoader();

        function loadBlockTexture(path) {
            const tex = textureLoader.load(path);
            loadedTextures.push(tex);
            return tex;
        }

        const texGrassTop = loadBlockTexture("textures/grass_top.png");
        const texGrassSide = loadBlockTexture("textures/grass_side.png");
        const texDirt = loadBlockTexture("textures/dirt.png");
        const texStone = loadBlockTexture("textures/stone.png");
        const texLogSide = loadBlockTexture("textures/log_side.png");
        const texLogTop = loadBlockTexture("textures/log_top.png");
        const texLeaves = loadBlockTexture("textures/leaves.png");

        // BoxGeometry 6 个面的顺序：
        // [right, left, top, bottom, front, back]
        const materials = {
            grass: [
                new THREE.MeshStandardMaterial({
                    map: texGrassSide,
                    roughness: 1,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texGrassSide,
                    roughness: 1,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texGrassTop,
                    roughness: 0.9,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texDirt,
                    roughness: 1,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texGrassSide,
                    roughness: 1,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texGrassSide,
                    roughness: 1,
                    metalness: 0
                })
            ],
            dirt: new THREE.MeshStandardMaterial({
                map: texDirt,
                roughness: 1,
                metalness: 0
            }),
            stone: new THREE.MeshStandardMaterial({
                map: texStone,
                roughness: 0.9,
                metalness: 0
            }),
            wood: [
                new THREE.MeshStandardMaterial({
                    map: texLogSide,
                    roughness: 0.8,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texLogSide,
                    roughness: 0.8,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texLogTop,
                    roughness: 0.7,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texLogTop,
                    roughness: 0.7,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texLogSide,
                    roughness: 0.8,
                    metalness: 0
                }),
                new THREE.MeshStandardMaterial({
                    map: texLogSide,
                    roughness: 0.8,
                    metalness: 0
                })
            ],
            leaf: new THREE.MeshStandardMaterial({
                map: texLeaves,
                transparent: true,
                opacity: 0.9,
                roughness: 0.8,
                metalness: 0,
                alphaTest: 0.5,
                side: THREE.DoubleSide
            })
        };

        function applyTextureQuality() {
            maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            loadedTextures.forEach((tex) => {
                if (!tex.image) return; // 跳过尚未完成加载的纹理，避免 undefined 报警
                tex.encoding = THREE.sRGBEncoding;
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestMipMapNearestFilter;
                tex.anisotropy = maxAnisotropy;
                tex.needsUpdate = true;
            });
        }

        function setupComposer() {
            const hasPostLib = EffectComposer && RenderPass && ShaderPass;
            const wantFXAA = ENABLE_FXAA && FXAAShader;
            if (!hasPostLib || !wantFXAA) {
                composer = null;
                fxaaPass = null;
                return;
            }

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            fxaaPass = new ShaderPass(FXAAShader);
            const pixelRatio = renderer.getPixelRatio();
            fxaaPass.uniforms["resolution"].value.set(
                1 / (window.innerWidth * pixelRatio),
                1 / (window.innerHeight * pixelRatio)
            );
            composer.addPass(fxaaPass);
        }

        function applyQualityPreset(mode) {
            const preset = qualityPresets[mode] || qualityPresets.balanced;
            qualityMode = mode;

            renderer.toneMappingExposure = preset.exposure;
            renderer.setPixelRatio(preset.pixelRatio);

            renderer.shadowMap.enabled = preset.shadows;
            if (directionalLight) {
                directionalLight.castShadow = preset.shadows;
                directionalLight.shadow.mapSize.set(
                    preset.shadowMapSize || 1024,
                    preset.shadowMapSize || 1024
                );
                directionalLight.shadow.bias = preset.shadowBias || -0.0005;
                directionalLight.shadow.normalBias = preset.normalBias || 0.02;
                directionalLight.shadow.radius = preset.shadowRadius ?? 1.0;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 260;
                directionalLight.shadow.camera.left = -90;
                directionalLight.shadow.camera.right = 90;
                directionalLight.shadow.camera.top = 120;
                directionalLight.shadow.camera.bottom = -40;
                directionalLight.shadow.camera.updateProjectionMatrix();
            }

            // 确保材质重新编译包含阴影定义
            Object.values(materials).forEach((mat) => {
                if (Array.isArray(mat)) {
                    mat.forEach((m) => (m.needsUpdate = true));
                } else {
                    mat.needsUpdate = true;
                }
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            setupComposer(); // 重新构建后期链路
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
                const pixelRatio = renderer.getPixelRatio();
                if (fxaaPass) {
                    fxaaPass.uniforms["resolution"].value.set(
                        1 / (window.innerWidth * pixelRatio),
                        1 / (window.innerHeight * pixelRatio)
                    );
                }
            }
            updateQualityLabel();
        }

        function cycleQualityPreset() {
            const order = ["performance", "balanced", "high"];
            const idx = order.indexOf(qualityMode);
            const next = order[(idx + 1) % order.length];
            applyQualityPreset(next);
        }

        function updateQualityLabel() {
            if (!qualityLabelEl) return;
            const preset = qualityPresets[qualityMode];
            qualityLabelEl.textContent = `画质：${qualityMode}（阴影${preset.shadows ? "开" : "关"}，像素比 ${preset.pixelRatio}，Q 切换）`;
        }

        function createSkyTexture() {
            const canvas = document.createElement("canvas");
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext("2d");
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#d6ecff");
            gradient.addColorStop(0.5, "#b7d5f4");
            gradient.addColorStop(1, "#9ac2e8");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const skyTexture = new THREE.CanvasTexture(canvas);
            skyTexture.encoding = THREE.sRGBEncoding;
            skyTexture.mapping = THREE.EquirectangularReflectionMapping;
            skyTexture.needsUpdate = true;
            return skyTexture;
        }

        // 用 Map 存世界里的方块，方便查重（存 type 与实例索引）
        const worldMap = new Map();
        function blockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        // ================== 简单噪声函数，生成地形 ==================
        function rand2D(x, z) {
            const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453;
            return s - Math.floor(s);
        }

        function fade(t) {
            return t * t * (3 - 2 * t); // Hermite smoothstep
        }

        // 插值平滑的值噪声（避免坑洼）
        function valueNoise(x, z, scale) {
            const px = x * scale;
            const pz = z * scale;
            const x0 = Math.floor(px);
            const z0 = Math.floor(pz);
            const x1 = x0 + 1;
            const z1 = z0 + 1;

            const fx = fade(px - x0);
            const fz = fade(pz - z0);

            const v00 = rand2D(x0, z0);
            const v10 = rand2D(x1, z0);
            const v01 = rand2D(x0, z1);
            const v11 = rand2D(x1, z1);

            const vx0 = v00 * (1 - fx) + v10 * fx;
            const vx1 = v01 * (1 - fx) + v11 * fx;
            return vx0 * (1 - fz) + vx1 * fz;
        }

        // 更平滑的高度：多频次 fBm，少量细节，避免尖锐坑洼
        function getHeightAt(x, z) {
            const octaves = [
                { scale: 0.02, amp: 1.0 },
                { scale: 0.04, amp: 0.55 },
                { scale: 0.08, amp: 0.25 }
            ];
            let sum = 0;
            let ampSum = 0;
            octaves.forEach((o) => {
                sum += valueNoise(x, z, o.scale) * o.amp;
                ampSum += o.amp;
            });
            let e = sum / ampSum;

            // 拉平极端（减少坑），让中段更平缓
            e = Math.pow(e, 0.85);

            // 控制绝对高度区间
            const minHeight = 7;
            const maxHeight = 15;
            return Math.round(minHeight + e * (maxHeight - minHeight));
        }

        // ================== 出生点计算（修好卡脚） ==================
        function getSpawnPosition() {
            const x = Math.floor(worldSize.width / 2);
            const z = Math.floor(worldSize.depth / 2);

            const blockCenterY = getHeightAt(x, z);  // 方块中心 y
            const groundTopY = blockCenterY + 0.5;   // 方块顶部 = 真正地面

            // 玩家脚底在地面上方一点点
            let spawnPos = new THREE.Vector3(
                x,
                groundTopY + playerHeight + 0.05,
                z
            );

            // 如果不小心和树 / 其他方块重叠，往上挪几次直到不碰撞
            for (let i = 0; i < 10; i++) {
                const collider = getPlayerCollider(spawnPos);
                if (!checkCollision(collider)) break;
                spawnPos.y += 0.5;
            }

            return spawnPos;
        }

        function resetPlayerPosition() {
            const spawnPos = getSpawnPosition();
            camera.position.copy(spawnPos);
            velocity.set(0, 0, 0);
            isGrounded = false;
        }

        // ================== 初始化 ==================
        function ensureInstancedGroup(type) {
            let group = instancedGroups.get(type);
            if (group) return group;
            const mat = materials[type] || materials["stone"];
            const mesh = new THREE.InstancedMesh(
                sharedBoxGeometry,
                mat,
                DEFAULT_INSTANCED_CAPACITY
            );
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mesh.userData.type = type;
            mesh.frustumCulled = false; // 禁用视锥裁剪，避免实例越界导致整批消失
            mesh.castShadow = type !== "leaf";
            mesh.receiveShadow = true;
            // 扩大包围盒/球，确保阴影渲染时不会因实例分布被裁切
            const center = new THREE.Vector3(
                worldSize.width / 2,
                worldSize.height,
                worldSize.depth / 2
            );
            const radius = Math.sqrt(
                worldSize.width * worldSize.width +
                    worldSize.height * worldSize.height +
                    worldSize.depth * worldSize.depth
            );
            mesh.geometry.computeBoundingBox();
            mesh.geometry.boundingBox.expandByPoint(center.clone().addScalar(radius));
            mesh.geometry.boundingSphere = new THREE.Sphere(center, radius);
            blocks.add(mesh);
            group = {
                mesh,
                capacity: DEFAULT_INSTANCED_CAPACITY,
                count: 0,
                positions: [],
                keys: []
            };
            instancedGroups.set(type, group);
            return group;
        }

        function setInstanceMatrix(mesh, index, position) {
            dummyObject.position.copy(position);
            dummyObject.rotation.set(0, 0, 0);
            dummyObject.scale.set(1, 1, 1);
            dummyObject.updateMatrix();
            mesh.setMatrixAt(index, dummyObject.matrix);
            mesh.instanceMatrix.needsUpdate = true;
        }

        function addInstancedBlock(x, y, z, type) {
            const key = blockKey(x, y, z);
            if (worldMap.has(key)) return;
            const group = ensureInstancedGroup(type);
            const idx = group.count;
            if (idx >= group.capacity) return; // 超容量直接忽略，避免错误
            const pos = new THREE.Vector3(x, y, z);
            group.positions[idx] = pos;
            group.keys[idx] = key;
            setInstanceMatrix(group.mesh, idx, pos);
            group.count += 1;
            group.mesh.count = group.count;
            worldMap.set(key, { type, index: idx });
        }

        function removeInstancedBlock(key) {
            const info = worldMap.get(key);
            if (!info) return;
            const group = instancedGroups.get(info.type);
            if (!group) return;
            const idx = info.index;
            const last = group.count - 1;
            if (idx < 0 || idx >= group.count) return;

            if (idx !== last) {
                // 把最后一个实例搬到当前位置
                const swapPos = group.positions[last];
                const swapKey = group.keys[last];
                group.positions[idx] = swapPos;
                group.keys[idx] = swapKey;
                setInstanceMatrix(group.mesh, idx, swapPos);
                worldMap.set(swapKey, { type: info.type, index: idx });
            }
            group.count -= 1;
            group.mesh.count = group.count;
            worldMap.delete(key);
        }

        function getHitPosition(intersection) {
            if (intersection.instanceId !== undefined) {
                const type = intersection.object.userData.type;
                const group = instancedGroups.get(type);
                if (group && group.positions[intersection.instanceId]) {
                    return group.positions[intersection.instanceId].clone();
                }
            }
            return intersection.object.position.clone();
        }

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.rotation.order = "YXZ";

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 高质量默认：sRGB 输出 + 软阴影 + 稍降像素比保持性能
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // 更优秀的胶片式映射
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap; // 稍硬阴影，清晰度更高

            document.body.appendChild(renderer.domElement);

            applyTextureQuality();

            // 天空/环境贴图 + 雾
            const skyTexture = createSkyTexture();
            scene.background = skyTexture;
            scene.environment = skyTexture;
            scene.fog = new THREE.FogExp2(0x7fb0d8, 0.0028);

            clock = new THREE.Clock();

            // 光照（升级到柔和阴影）
            hemiLight = new THREE.HemisphereLight(0xddeeff, 0x889988, 0.4); // 降低环境光，让阴影对比更明显
            scene.add(hemiLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // 提升主光强度，增加阴影存在感
            directionalLight.position.set(80, 120, 60);
            scene.add(directionalLight);

            // 方块组
            blocks = new THREE.Group();
            scene.add(blocks);

            // 生成世界
            generateWorld();

            // 把玩家放到一个安全的出生点（地面上方）
            resetPlayerPosition();

            // Raycaster
            raycaster = new THREE.Raycaster();

            // 高亮方块轮廓
            const outlineGeometry = new THREE.EdgesGeometry(
                new THREE.BoxGeometry(1.01, 1.01, 1.01)
            );
            const outlineMaterial = new THREE.LineBasicMaterial({
                color: 0x000000
            });
            outlineMesh = new THREE.LineSegments(
                outlineGeometry,
                outlineMaterial
            );
            outlineMesh.visible = false;
            scene.add(outlineMesh);

            // 后期处理：RenderPass + FXAA/SSAO（高画质用 SSAO 替代阴影）
            setupComposer();

            // 质量标签
            qualityLabelEl = document.createElement("p");
            qualityLabelEl.id = "quality-label";
            document.getElementById("info").appendChild(qualityLabelEl);

            // UI 事件
            setupEventListeners();

            // 创建物品栏
            createInventoryBar();

            applyQualityPreset(qualityMode);
            animate();
        }

        // ================== 世界生成 ==================
        function generateWorld() {
            for (let x = 0; x < worldSize.width; x++) {
                for (let z = 0; z < worldSize.depth; z++) {
                    const yTop = getHeightAt(x, z);

                    // 顶层草
                    addBlockWithGeometry(x, yTop, z, "grass");

                    // 下面几层泥土
                    for (let dy = yTop - 1; dy > yTop - 4 && dy > 0; dy--) {
                        addBlockWithGeometry(x, dy, z, "dirt");
                    }
                    // 再下面是石头
                    for (let dy = yTop - 4; dy > 0; dy--) {
                        addBlockWithGeometry(x, dy, z, "stone");
                    }
                    // 基岩
                    addBlockWithGeometry(x, 0, z, "stone");

                    // 随机生成树（稍低门槛，扩大世界仍有树木）
                    if (Math.random() < 0.035 && yTop > worldSize.height * 0.5) {
                        generateTree(x, yTop + 1, z);
                    }
                }
            }
        }

        function generateTree(x, y, z) {
            const trunkHeight = Math.floor(Math.random() * 3) + 4; // 4-6
            // 树干
            for (let i = 0; i < trunkHeight; i++) {
                addBlock(x, y + i, z, "wood");
            }
            const topY = y + trunkHeight;

            // 叶子层
            for (let lx = -2; lx <= 2; lx++) {
                for (let ly = -1; ly <= 1; ly++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        if (lx === 0 && lz === 0 && ly < 1) continue;
                        if (Math.abs(lx) + Math.abs(lz) > 4) continue;
                        addBlock(x + lx, topY + ly, z + lz, "leaf");
                    }
                }
            }
            // 顶部几片叶子
            addBlock(x, topY + 2, z, "leaf");
            addBlock(x + 1, topY + 2, z, "leaf");
            addBlock(x - 1, topY + 2, z, "leaf");
            addBlock(x, topY + 2, z + 1, "leaf");
            addBlock(x, topY + 2, z - 1, "leaf");
        }

        // 复用几何体版本
        function addBlockWithGeometry(x, y, z, type) {
            addInstancedBlock(x, y, z, type);
        }

        function addBlock(x, y, z, type) {
            addInstancedBlock(x, y, z, type);
        }

        // ================== 事件 & 物品栏 ==================
        function createInventoryBar() {
            const inventoryBar = document.getElementById("inventory-bar");
            for (let i = 0; i < blockTypes.length; i++) {
                const slot = document.createElement("div");
                slot.classList.add("inventory-slot");
                slot.dataset.index = i;
                slot.textContent = blockTypes[i];
                inventoryBar.appendChild(slot);
            }
            updateInventoryUI();
        }

        function updateInventoryUI() {
            const slots = document.querySelectorAll(".inventory-slot");
            slots.forEach((slot) => {
                if (parseInt(slot.dataset.index) === currentBlockIndex) {
                    slot.classList.add("selected");
                } else {
                    slot.classList.remove("selected");
                }
            });
        }

        function setupEventListeners() {
            document.addEventListener("keydown", (e) => {
                if (e.key === 'Escape') {
                    window.location.href = 'help.html'
                    return
                }
                if (e.key === 'q' || e.key === 'Q') {
                    cycleQualityPreset();
                    return;
                }
                keys[e.code] = true;
            });
            document.addEventListener("keyup", (e) => {
                keys[e.code] = false;
            });

            // 点击进入指针锁定
            document.addEventListener("click", () => {
                document.body.requestPointerLock();
            });

            // 鼠标控制视角
            document.addEventListener("mousemove", (e) => {
                if (document.pointerLockElement === document.body) {
                    const sensitivity = 0.002;
                    camera.rotation.y -= e.movementX * sensitivity;
                    camera.rotation.x -= e.movementY * sensitivity;
                    const halfPi = Math.PI / 2;
                    camera.rotation.x = Math.max(
                        -halfPi,
                        Math.min(halfPi, camera.rotation.x)
                    );
                }
            });

            // 鼠标点击破坏/放置
            document.addEventListener("mousedown", (e) => {
                if (
                    document.pointerLockElement !== document.body ||
                    !selectedBlock
                )
                    return;

                if (e.button === 0) {
                    // 左键破坏
                    const hitPos = getHitPosition(selectedBlock);
                    const key = blockKey(hitPos.x, hitPos.y, hitPos.z);
                    removeInstancedBlock(key);
                    selectedBlock = null;
                    outlineMesh.visible = false;
                } else if (e.button === 2) {
                    // 右键放置
                    const normal = selectedBlock.face.normal;
                    const hitPos = getHitPosition(selectedBlock);
                    const newPos = hitPos.clone().add(normal);
                    const playerCollider = getPlayerCollider(camera.position);
                    const newBlockCollider = new THREE.Box3()
                        .setFromCenterAndSize(
                            newPos,
                            new THREE.Vector3(
                                blockSize,
                                blockSize,
                                blockSize
                            )
                        );
                    if (!playerCollider.intersectsBox(newBlockCollider)) {
                        addBlock(
                            newPos.x,
                            newPos.y,
                            newPos.z,
                            blockTypes[currentBlockIndex]
                        );
                    }
                }
            });

            // 滚轮切换方块
            document.addEventListener("wheel", (e) => {
                if (e.deltaY > 0) {
                    currentBlockIndex =
                        (currentBlockIndex + 1) % blockTypes.length;
                } else {
                    currentBlockIndex =
                        (currentBlockIndex - 1 + blockTypes.length) %
                        blockTypes.length;
                }
                updateInventoryUI();
            });

            // 窗口大小变化
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                applyQualityPreset(qualityMode);
            });

            // 禁用默认右键菜单
            window.addEventListener("contextmenu", (e) =>
                e.preventDefault()
            );
        }

        // ================== 碰撞 & 物理 ==================
        function getPlayerCollider(position) {
            const center = position
                .clone()
                .sub(new THREE.Vector3(0, playerHeight / 2, 0));
            return new THREE.Box3().setFromCenterAndSize(
                center,
                playerBoxSize
            );
        }

        function checkCollision(playerCollider) {
            // 确定玩家碰撞盒覆盖的整数坐标范围
            const minX = Math.floor(playerCollider.min.x);
            const maxX = Math.ceil(playerCollider.max.x);
            const minY = Math.floor(playerCollider.min.y);
            const maxY = Math.ceil(playerCollider.max.y);
            const minZ = Math.floor(playerCollider.min.z);
            const maxZ = Math.ceil(playerCollider.max.z);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = blockKey(x, y, z);
                        if (worldMap.has(key)) {
                            const blockCollider = new THREE.Box3().setFromCenterAndSize(
                                new THREE.Vector3(x, y, z),
                                new THREE.Vector3(blockSize, blockSize, blockSize)
                            );
                            if (playerCollider.intersectsBox(blockCollider)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateControls(delta) {
            const yaw = camera.rotation.y;
            const forward = new THREE.Vector3(
                -Math.sin(yaw),
                0,
                -Math.cos(yaw)
            );
            const right = new THREE.Vector3(
                Math.cos(yaw),
                0,
                -Math.sin(yaw)
            );

            moveVector.set(0, 0, 0);

            if (keys["KeyW"]) moveVector.add(forward);
            if (keys["KeyS"]) moveVector.sub(forward);
            if (keys["KeyA"]) moveVector.sub(right);
            if (keys["KeyD"]) moveVector.add(right);

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(moveSpeed);
            }

            velocity.x = moveVector.x;
            velocity.z = moveVector.z;

            // 跳跃
            if (keys["Space"] && isGrounded) {
                velocity.y = jumpStrength;
                isGrounded = false;
            }
        }

        function updatePhysics(delta) {
            // 重力
            velocity.y -= gravity * delta;

            const oldPos = camera.position.clone();
            const newPos = oldPos.clone();

            // 垂直轴
            newPos.y += velocity.y * delta;
            let playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                if (velocity.y < 0) {
                    isGrounded = true;
                }
                velocity.y = 0;
                newPos.y = oldPos.y;
            } else {
                isGrounded = false;
            }

            // X 轴
            newPos.x += velocity.x * delta;
            playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                newPos.x = oldPos.x;
            }

            // Z 轴
            newPos.z += velocity.z * delta;
            playerCollider = getPlayerCollider(newPos);
            if (checkCollision(playerCollider)) {
                newPos.z = oldPos.z;
            }

            camera.position.copy(newPos);

            // 掉出世界就传送回安全出生点
            if (camera.position.y < -20) {
                resetPlayerPosition();
            }
        }

        // ================== 交互（选中方块） ==================
        function updateInteraction() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObjects(
                blocks.children,
                false
            );

            if (intersects.length > 0 && intersects[0].distance < reachDistance) {
                selectedBlock = intersects[0];
                const hitPos = getHitPosition(selectedBlock);
                outlineMesh.position.copy(hitPos);
                outlineMesh.visible = true;
            } else {
                selectedBlock = null;
                outlineMesh.visible = false;
            }
        }

        // ================== 动画循环 ==================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // 不再检查 pointerLockElement，始终更新控制和物理
            updateControls(delta);
            updatePhysics(delta);

            updateInteraction();
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        init();
    </script>
</body>
</html>

